// FindCoinEvent.cpp : Defines the exported functions for the DLL application.
//

#include "stdafx.h"
#include"FindCoinEvent.h"
#include <stdio.h>
#include <math.h>
//**********************


void findCoinEvent (
	const unsigned *data,
	const int      dataLength,
	const unsigned A_ModInfo[2],
	const unsigned B_ModInfo[2],
	const unsigned energyWindow[2][144][2],
	const double   tunedTDC[2][144][512],
	const double   CoinWindow,
	int64_t        &A_ModCycle,		
	int64_t        &B_ModCycle,			//A、B模块的大周期
	int64_t        &LoopStartID,
	int64_t        &CoinNumInCoinWindow,
	int64_t        &DelayNumInCoinWindow,	
	unsigned short int   A_CoinMap[3072][3072],
	unsigned short int   B_CoinMap[3072][3072]
)
{
	
	
	int module_id;
	int cell_id;
	
	int blk_ax, blk_ax_a, blk_ax_b;
	int blk_tr, blk_tr_a, blk_tr_b;
	int pos_ax, pos_ax_a, pos_ax_b;
	int pos_tr, pos_tr_a, pos_tr_b;
	int map_tr_a, map_tr_b, map_ax_a, map_ax_b;
	int energy;
	int tdc;
	int doi;
	
	
	int RT;
	int MKBite1;
	int MKBite2;
	int MKBite3;
	int Tag0;
	int Tag1;
	int highTM;
	int lowTM;
	int TM;
	double time, TimeDelay;
	int DelayTimeCycle = 10;

	EffSingleInfo CurrentSingle; //声明一个名为CurrentSingle的变量，数据类型为结构体EffSingleInfo，在头文件中已做定义
	vector < EffSingleInfo > A_ModSingle;
	vector < EffSingleInfo > B_ModSingle;//声明两个向量变量，数据类型为结构体EffSingleInfo
	size_t B_LoopStart = 0;
	int64_t A_NowCycle = A_ModCycle;
	int64_t B_NowCycle = B_ModCycle;//读取DLL外部的寄存器，获取当前的大周期
	A_ModSingle.clear();
	B_ModSingle.clear();
	
	for ( int i = 0; i < dataLength; i ++ )
	{
		RT   = ( data[ i ] >> 0 ) & 0x1;
		Tag0 = ( data[ i ] >> 1 ) & 0x3;
		Tag1 = ( data[ i ] >> 3 ) & 0x3;
		MKBite1 = ( data[ i ] >> 30 ) & 0x3;
		MKBite2 = ( data[ i + 1 ] >> 30 ) & 0x3;
		MKBite3 = ( data[ i + 2 ] >> 30 ) & 0x3;
		TM      = ( (( data[i] >> 5 ) & 0x3 ) << 10 ) + ( ( data[ i + 2 ] >> 5 ) & 0x3ff );
		//TM = ( data[ i + 2 ] >> 5 ) & 0xFFF;
		
		if ( RT == 0 && Tag0 == 1 && Tag1 == 2 && MKBite1 == 0 && MKBite2 == 1 && MKBite3 == 2 )  
		{
			module_id  = ( data[ i + 2] >> 0 ) & 0x1f;
			cell_id = ( data[ i + 1] >> 6 ) & 0x7;
			doi = ( data[ i ] >> 5 ) & 0xf;
			blk_ax  = ( data[ i ] >> 26 ) & 0xf; 
			blk_tr  = ( data[ i + 1 ] >> 2 ) & 0xf;
			pos_ax  = ( data[ i ] >> 10 ) & 0xff;
			pos_tr  = ( data[ i ] >> 18 ) & 0xff;
			energy  = ( data[ i + 1 ] >> 9 ) & 0x3ff;
			tdc     = ( data[ i + 1 ] >> 20 ) & 0x1ff;
			highTM  = (TM >> 11) & 0x1;
			lowTM   = TM & 0x7ff;
	
			int group_id = 12 * blk_tr + blk_ax;
			
			
			if (module_id == A_ModInfo[ 0 ])
			{				
	    		if ( highTM == 0 && lowTM == 0 )
	    		{
	    			A_NowCycle += 1;
	     		}
	    		else
	    		{
		    		if ( highTM == 1 )
		    		{
			    		A_NowCycle += 1;
			    	}
		    	}				
			    if ( cell_id  == A_ModInfo[ 1 ] && (TM != 0) && energy >= energyWindow[0][group_id][0] && energy <= energyWindow[0][group_id][1] )
				{				
		         	time = A_NowCycle * 2048 * 6250 + lowTM * 6250 + tunedTDC[0][ group_id ][ tdc ];					
				   	CurrentSingle.rawE     = energy;
				   	CurrentSingle.tunedT   = time;
					CurrentSingle.DelayT   = time;
				    CurrentSingle.eventid  = int64_t( i );
				    CurrentSingle.cycleNum = A_NowCycle;
					CurrentSingle.mod_id = module_id;
					CurrentSingle.cell_id = cell_id;
					CurrentSingle.microBlk_tr = blk_tr;
					CurrentSingle.microBlk_ax = blk_ax;
					CurrentSingle.group_i = group_id;
					CurrentSingle.pos_tr = pos_tr;
					CurrentSingle.pos_ax = pos_ax;
			  	    A_ModSingle.push_back( CurrentSingle );
					
				}	
								
			}

			if (module_id == B_ModInfo[ 0 ] )
			{
	    		if ( highTM == 0 && lowTM == 0 )
	    		{
	    			B_NowCycle += 1;
	     		}
	    		else
	    		{
		    		if ( highTM == 1 )
		    		{
			    		B_NowCycle += 1;
			    	}
		    	}
           	    if ( cell_id  == B_ModInfo[ 1 ] && (TM != 0)&& energy >= energyWindow[1][group_id][0] && energy <= energyWindow[1][group_id][1] )
				{
					time = B_NowCycle * 2048 * 6250 + lowTM * 6250 + tunedTDC[1][ group_id ][ tdc ];					
				   	CurrentSingle.rawE     = energy;
				   	CurrentSingle.tunedT   = time;
					CurrentSingle.DelayT   = B_NowCycle * 2048 * 6250 + lowTM * 6250 + tunedTDC[1][ group_id ][ tdc ] + DelayTimeCycle * 6250;
				    CurrentSingle.eventid  = int64_t( i );
				    CurrentSingle.cycleNum = B_NowCycle;
					CurrentSingle.mod_id = module_id;
					CurrentSingle.cell_id = cell_id;
					CurrentSingle.microBlk_tr = blk_tr;
					CurrentSingle.microBlk_ax = blk_ax;
					CurrentSingle.group_i = group_id;
					CurrentSingle.pos_tr = pos_tr;
					CurrentSingle.pos_ax = pos_ax;
			  	    B_ModSingle.push_back( CurrentSingle );
				}    	
			}
			
		}  
		
	}
	
	
	//---------------------------calculate number of events delayed----------------------------------------
	for ( size_t ia = 0; ia < A_ModSingle.size(); ia ++ )//遍历左边cell的event
	{
		for ( size_t ib = B_LoopStart; ib < B_ModSingle.size(); ib ++ )//遍历右边cell的event
		{
			if ( B_ModSingle[ ib ].DelayT - A_ModSingle[ ia ].DelayT > CoinWindow )
			break;

			else if ( abs( B_ModSingle[ ib ].DelayT - A_ModSingle[ ia ].DelayT ) <= CoinWindow )
			{
				DelayNumInCoinWindow += 1;
				B_LoopStart = ib + size_t( 1 );
			}
		}
	}

	B_LoopStart = 0;
	
	//-----------------------------------done-------------------------------------------------------------

	

	for ( size_t ia = 0; ia < A_ModSingle.size(); ia ++ )//遍历左边cell的event
	{
		
		for ( size_t ib = B_LoopStart; ib < B_ModSingle.size(); ib ++ )//遍历右边cell的event
		{
			auto deltaTdcAB = B_ModSingle[ ib ].tunedT - A_ModSingle[ ia ].tunedT;
			int group_i_a = A_ModSingle[ia].group_i;
			int group_i_b = B_ModSingle[ib].group_i;

			if (deltaTdcAB > CoinWindow )
			break;
			else if (abs(deltaTdcAB) <= CoinWindow && group_i_a == group_i_b )//筛选条件：group级别位置对位；TA-TB在时间窗内。
			{
				CoinNumInCoinWindow += 1;
				B_LoopStart = ib + size_t( 1 );

				map_tr_a = A_ModSingle[ia].microBlk_tr * 256 + A_ModSingle[ia].pos_tr;
				map_ax_a = A_ModSingle[ia].microBlk_ax * 256 + A_ModSingle[ia].pos_ax;
				map_tr_b = B_ModSingle[ib].microBlk_tr * 256 + B_ModSingle[ib].pos_tr;
				map_ax_b = B_ModSingle[ib].microBlk_ax * 256 + B_ModSingle[ib].pos_ax;
				
				A_CoinMap[map_tr_a][map_ax_a] ++; 
				B_CoinMap[map_tr_b][map_ax_b] ++;

				if ( A_ModSingle[ ia ].eventid > B_ModSingle[ ib ].eventid )
				{
					LoopStartID = 1 + A_ModSingle[ ia ].eventid;
					A_ModCycle = A_ModSingle[ ia ].cycleNum;
					B_ModCycle = B_ModSingle[ ib ].cycleNum;
					for ( size_t iib = ib; iib < ib + 50; iib ++ )
					{
						if ( B_ModSingle[ iib ].eventid > A_ModSingle[ ia ].eventid )
						{
							B_ModCycle = B_ModSingle[ iib - 1 ].cycleNum;
							break;
						}
					}
				}

				if ( A_ModSingle[ ia ].eventid < B_ModSingle[ ib ].eventid )
				{
					LoopStartID = 1 + B_ModSingle[ ib ].eventid;
					B_ModCycle = B_ModSingle[ ib ].cycleNum;
					A_ModCycle = A_ModSingle[ ia ].cycleNum;
					for ( size_t iia = ia; iia < ia + 50; iia ++ )
					{
						if ( A_ModSingle[ iia ].eventid > B_ModSingle[ ib ].eventid )
						{
							A_ModCycle = A_ModSingle[ iia - 1 ].cycleNum;
							break;
						}
					}
				}			
			
				break;
			}
			
		}
	}

	
	A_ModSingle.clear();
	B_ModSingle.clear();

		
}
